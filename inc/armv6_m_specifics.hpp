#pragma once

#include "code_generation.hpp"
#include "removing_security_hazard.hpp"

void available_register_assignment_armv6m(std::vector<TAC_type>& TAC, std::vector<TAC_bb>& control_flow_TAC, const std::vector<liveness_interval_struct>::iterator& first_interval_without_real_register_iterator, std::vector<liveness_interval_struct>& liveness_intervals, std::vector<liveness_interval_struct>& active, std::vector<std::tuple<uint32_t, uint8_t, uint32_t, uint32_t, bool>>& available_registers, std::vector<std::tuple<uint32_t, uint32_t, uint8_t>>& allocated_registers, memory_security_struct& memory_security, const std::map<uint32_t, std::vector<uint32_t>>& predecessors, std::vector<std::tuple<uint32_t, uint32_t, uint32_t, uint32_t>>& track_xor_specification_armv6m, std::vector<std::tuple<uint32_t, uint32_t, uint8_t, uint8_t, uint32_t, uint8_t, uint32_t>>& postponed_store_insertion);
void get_intervals_in_line_with_xor_specification(const std::vector<TAC_type>& TAC, std::vector<liveness_interval_struct>& liveness_intervals, memory_security_struct& memory_security);
uint8_t insert_load_armv6m(uint32_t in_dest, uint8_t in_dest_sens, uint8_t in_overall_sens, uint32_t in_src2, std::vector<TAC_type>& TAC, std::vector<TAC_bb>& control_flow_TAC, uint32_t instruction_idx_to_insert, std::vector<liveness_interval_struct>& liveness_intervals, std::vector<liveness_interval_struct>& active, std::vector<std::tuple<uint32_t, uint8_t, uint32_t, uint32_t, bool>>& available_registers,  std::vector<std::tuple<uint32_t, uint32_t, uint32_t, uint32_t>>& track_xor_specification_armv6m, std::vector<std::tuple<uint32_t, uint32_t, uint8_t, uint8_t, uint32_t, uint8_t, uint32_t>>& postponed_store_insertion);
void insert_store_armv6m(uint32_t in_dest, uint8_t in_dest_sens, uint8_t in_overall_sens, uint32_t in_src1, uint8_t in_src1_sens, std::vector<TAC_type>& TAC, std::vector<TAC_bb>& control_flow_TAC, uint32_t instruction_idx_to_insert, uint32_t start_range_of_latest_interval, std::vector<liveness_interval_struct>& liveness_intervals, std::vector<liveness_interval_struct>& active, std::vector<std::tuple<uint32_t, uint8_t, uint32_t, uint32_t, bool>>& available_registers, std::vector<std::tuple<uint32_t, uint32_t, uint32_t, uint32_t>>& track_xor_specification_armv6m, uint32_t index_of_interval_to_store, std::vector<std::tuple<uint32_t, uint32_t, uint8_t, uint8_t, uint32_t, uint8_t, uint32_t>>& postponed_store_insertion, const std::map<uint32_t, std::vector<uint32_t>>& predecessors);
void insert_prolog_armv6m(std::vector<TAC_type>& TAC, uint32_t& bytes_to_reserve, std::set<uint32_t>& non_scratch_register_used);
void move_specification_armv6m(Operation& op, uint32_t src, bool& psr_status_flag);
uint8_t add_specification_armv6m(uint32_t src2, bool& add_psr_status_flag, TAC_type& load_number_to_reg_tac);
void insert_epilog_armv6m(std::vector<TAC_type>& TAC, std::set<uint32_t>& non_scratch_register_used, uint32_t bytes_to_reserve, std::vector<stack_local_variable_tracking_struct>& stack_mapping_tracker);
bool assignment_breaks_xor_specifications(const std::tuple<uint32_t, uint8_t, uint32_t, uint32_t, bool>& available_register, const liveness_interval_struct& liveness_interval, const std::vector<std::tuple<uint32_t, uint32_t, uint32_t, uint32_t>>& track_xor_specification_armv6m);
bool armv6_m_xor_specification_is_empty(const std::vector<std::tuple<uint32_t, uint32_t>>& armv6_m_specification);
bool armv6_m_xor_specification_contains_instruction(const std::vector<std::tuple<uint32_t, uint32_t>>& armv6_m_specification, uint32_t new_intersection_point);
bool virtual_register_at_src_TAC_instruction_has_armv6_m_xor_specification(TAC_type& TAC_instr, uint32_t instruction_idx, uint32_t& virtual_register, const std::vector<std::tuple<uint32_t, uint32_t>>& armv6_m_specification);
void and_specification_armv6m(std::vector<TAC_type>& TAC, TAC_OPERAND& src2_type, uint32_t& src2_v);
void add_t1_encoding_specification_armv6m(std::vector<TAC_type>& TAC, uint32_t dest, uint32_t src1, uint32_t src2);